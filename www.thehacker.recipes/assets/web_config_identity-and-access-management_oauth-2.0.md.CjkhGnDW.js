import{_ as t,c as a,a5 as i,o as r}from"./chunks/framework.B5CpDqM0.js";const p=JSON.parse('{"title":"üõ†Ô∏è OAuth 2.0","description":"","frontmatter":{"authors":"KenjiEndo15, ShutdownRepo"},"headers":[],"relativePath":"web/config/identity-and-access-management/oauth-2.0.md","filePath":"web/config/identity-and-access-management/oauth-2.0.md","lastUpdated":1724982529000}'),o={name:"web/config/identity-and-access-management/oauth-2.0.md"};function n(s,e,h,c,l,d){return r(),a("div",null,e[0]||(e[0]=[i('<h1 id="üõ†Ô∏è-oauth-2-0" tabindex="-1">üõ†Ô∏è OAuth 2.0 <a class="header-anchor" href="#üõ†Ô∏è-oauth-2-0" aria-label="Permalink to &quot;üõ†Ô∏è OAuth 2.0&quot;">‚Äã</a></h1><h2 id="theory" tabindex="-1">Theory <a class="header-anchor" href="#theory" aria-label="Permalink to &quot;Theory&quot;">‚Äã</a></h2><p>OAuth 2.0 is a widely used framework across websites on the internet. It provides authorization.<br> Example: it allows a third-party application to access a user&#39;s resource (name, age, location, etc.).</p><p>Over time, OAuth 2.0 also started to provide authentication (check <a href="https://openid.net/connect/" target="_blank" rel="noreferrer">OpenID Connect</a>).<br> Example: it allows a user to connect to a third-party website using its social media accounts.</p><p>Before understanding the attack vectors, one must understand the basics of OAuth 2.0&#39;s mechanism. In order to keep this note short and handy for pentesters, the details will be left out (links to relevant articles will be provided).</p><h3 id="misconfigurations" tabindex="-1">Misconfigurations <a class="header-anchor" href="#misconfigurations" aria-label="Permalink to &quot;Misconfigurations&quot;">‚Äã</a></h3><p>The exploitation will depend on the misconfiguration. The next image shows a road that can be followed:</p><p>//TODO üõ†Ô∏è Image here.</p><p>The misconfiguration types can be better understood with this table:</p><table tabindex="0"><thead><tr><th>Misconfiguration types</th><th>Description</th></tr></thead><tbody><tr><td>Redirect URI Validation Attacks (Authorization Code Grant)</td><td><code>https://*.somesite.example/*</code> trusts <code>https://attacker.example/example</code></td></tr><tr><td>Redirect URI Validation Attacks (Implicit Grant)</td><td><code>https://client.somesite.example/cb?*</code> trusts anything after <code>cb?</code></td></tr></tbody></table><h2 id="practice" tabindex="-1">Practice <a class="header-anchor" href="#practice" aria-label="Permalink to &quot;Practice&quot;">‚Äã</a></h2><div class="tip custom-block"><p>For each misconfiguration described below, check the countermeasures presented in the <a href="https://tools.ietf.org/id/draft-ietf-oauth-security-topics-15.html#name-attacks-and-mitigations" target="_blank" rel="noreferrer">OAuth 2.0 Security Best Current Practice</a>. Even if some misconfigurations are present, the information retrieved from them may not be usable due to countermeasures applied.</p></div><h3 id="insufficient-redirect-uri-validation" tabindex="-1">Insufficient Redirect URI Validation <a class="header-anchor" href="#insufficient-redirect-uri-validation" aria-label="Permalink to &quot;Insufficient Redirect URI Validation&quot;">‚Äã</a></h3><p>In some cases, clients are allowed to use pattern matching in the definition of their redirect URI. The authorization server then verifies that URI. When the URI pattern is not defined properly, and the validation is insufficient, it can lead to an attacker stealing the authorization code or access token.</p><h4 id="authorization-code-grant" tabindex="-1">Authorization Code Grant <a class="header-anchor" href="#authorization-code-grant" aria-label="Permalink to &quot;Authorization Code Grant&quot;">‚Äã</a></h4><p>Upon getting a <code>client_id</code>, it&#39;s possible to test this misconfiguration by providing the authorization server with a fake URI. Depending on the server&#39;s HTTP response, misconfiguration is present.</p><p>In the case where the client is confidential (requiring authentication with the client&#39;s secret), one can bypass it by using the Authorization Code Injection attack.</p><h4 id="implicit-grant" tabindex="-1">Implicit Grant <a class="header-anchor" href="#implicit-grant" aria-label="Permalink to &quot;Implicit Grant&quot;">‚Äã</a></h4><p>To test the redirect URI validation misconfiguration with the implicit grant, the client application needs to hold an <a href="./../../../web/inputs/ored">open redirect</a> vulnerability. The implicit grant is handy for targeting wildcards on query parameters.</p><p>Upon getting a <code>client_id</code>, it&#39;s possible to test this misconfiguration by abusing the open redirect vulnerability and providing the authorization server with a fake URI. Depending on the server&#39;s HTTP response, misconfiguration is present.</p><h3 id="credential-leakage-via-referer-headers" tabindex="-1">Credential Leakage via Referer Headers <a class="header-anchor" href="#credential-leakage-via-referer-headers" aria-label="Permalink to &quot;Credential Leakage via Referer Headers&quot;">‚Äã</a></h3><p>The <code>referer</code> header could leak important information such as the authorization code, the state, or the access token.</p><h4 id="leakage-from-the-oauth-client" tabindex="-1">Leakage from the OAuth Client <a class="header-anchor" href="#leakage-from-the-oauth-client" aria-label="Permalink to &quot;Leakage from the OAuth Client&quot;">‚Äã</a></h4><p>When a client gets to a page as a result of a successful authorization request, the tester has to check whether the page:</p><ul><li>contains links to other pages under an attacker&#39;s control,</li><li>a third-party content (iframes, images...) that can be loaded.</li></ul><h4 id="leakage-from-the-authorization-server" tabindex="-1">Leakage from the Authorization Server <a class="header-anchor" href="#leakage-from-the-authorization-server" aria-label="Permalink to &quot;Leakage from the Authorization Server&quot;">‚Äã</a></h4><p>In a similar way, the tester has to check the same points as the OAuth client, but in the authorization server endpoint.</p><h3 id="credential-leakage-via-browser-history" tabindex="-1">Credential Leakage via Browser History <a class="header-anchor" href="#credential-leakage-via-browser-history" aria-label="Permalink to &quot;Credential Leakage via Browser History&quot;">‚Äã</a></h3><p>If an attacker has an access to a victim&#39;s browser, it can search for authorization codes and access tokens present in the history of visited URLs.</p><h3 id="authorization-code-injection" tabindex="-1">Authorization Code Injection <a class="header-anchor" href="#authorization-code-injection" aria-label="Permalink to &quot;Authorization Code Injection&quot;">‚Äã</a></h3><p>The goal here is to impersonate a victim by injecting a stolen authorization code into the attacker&#39;s own session with the client. Confidential clients are targeted by this attack. <br> This attack is not possible if:</p><ul><li>The client sends a <code>code_challenge</code> in the Authorization request, which means it&#39;s using <a href="https://oauth.net/2/pkce/" target="_blank" rel="noreferrer">PKCE</a> to prevent some of the OAuth attacks.</li><li>The client in an OpenID Connect layer uses a <code>nonce</code> to prevents replay attacks.</li></ul><h3 id="cross-site-request-forgery-csrf" tabindex="-1">Cross-Site Request Forgery CSRF <a class="header-anchor" href="#cross-site-request-forgery-csrf" aria-label="Permalink to &quot;Cross-Site Request Forgery CSRF&quot;">‚Äã</a></h3><p>If the <code>state</code> parameter is not used in the authentication request, a CSRF attack is possible.</p><h2 id="resources" tabindex="-1">Resources <a class="header-anchor" href="#resources" aria-label="Permalink to &quot;Resources&quot;">‚Äã</a></h2><p><a href="https://tools.ietf.org/id/draft-ietf-oauth-security-topics-15.html#name-access-token-injection" target="_blank" rel="noreferrer">https://tools.ietf.org/id/draft-ietf-oauth-security-topics-15.html#name-access-token-injection</a></p><p><a href="https://securityhubs.io/oauth2_threat_model.html" target="_blank" rel="noreferrer">https://securityhubs.io/oauth2_threat_model.html</a></p><p><a href="https://www.oauth.com/" target="_blank" rel="noreferrer">https://www.oauth.com/</a></p><p><a href="https://portswigger.net/web-security/oauth" target="_blank" rel="noreferrer">https://portswigger.net/web-security/oauth</a></p>',39)]))}const f=t(o,[["render",n]]);export{p as __pageData,f as default};
