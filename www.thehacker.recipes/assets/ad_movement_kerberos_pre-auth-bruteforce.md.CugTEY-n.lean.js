import{_ as s,c as a,a5 as t,o as i}from"./chunks/framework.B5CpDqM0.js";const u=JSON.parse('{"title":"Pre-auth bruteforce","description":"","frontmatter":{"authors":"ShutdownRepo, sckdev"},"headers":[],"relativePath":"ad/movement/kerberos/pre-auth-bruteforce.md","filePath":"ad/movement/kerberos/pre-auth-bruteforce.md","lastUpdated":1724982529000}'),r={name:"ad/movement/kerberos/pre-auth-bruteforce.md"};function n(o,e,h,p,l,c){return i(),a("div",null,e[0]||(e[0]=[t(`<h1 id="pre-auth-bruteforce" tabindex="-1">Pre-auth bruteforce <a class="header-anchor" href="#pre-auth-bruteforce" aria-label="Permalink to &quot;Pre-auth bruteforce&quot;">​</a></h1><h2 id="theory" tabindex="-1">Theory <a class="header-anchor" href="#theory" aria-label="Permalink to &quot;Theory&quot;">​</a></h2><p>The Kerberos authentication protocol works with tickets in order to grant access. A ST (Service Ticket) can be obtained by presenting a TGT (Ticket Granting Ticket). That prior TGT can only be obtained by validating a first step named &quot;pre-authentication&quot; (except if that requirement is explicitly removed for some accounts, making them vulnerable to <a href="./asreproast">ASREProast</a>).</p><p>The pre-authentication requires the requesting user to supply its secret key (DES, RC4, AES128 or AES256) derived from his password. An attacker knowing that secret key doesn&#39;t need knowledge of the actual password to obtain tickets. This is called <a href="./ptk">pass-the-key</a>.</p><p>Sometimes, the pre-authentication is disabled on some accounts. The attacker can then obtain information encrypted with the account&#39;s key. While the obtained TGT cannot be used since it&#39;s encrypted with a key the attacker has no knowledge of, the encrypted information can be used to bruteforce the account&#39;s password. This is called <a href="./asreproast">ASREProast</a>.</p><p>Last but not least, the pre-authentication step can be bruteforced. This type of credential bruteforcing is way faster and stealthier than other bruteforcing methods relying on NTLM. Pre-authentication bruteforcing can even be faster by using UDP as the transport protocol, hence requiring less frames to be sent.</p><p>On a side note, it is possible to enumerate domain users in a similar manner.</p><h2 id="practice" tabindex="-1">Practice <a class="header-anchor" href="#practice" aria-label="Permalink to &quot;Practice&quot;">​</a></h2><h3 id="users-enum" tabindex="-1">Users enum <a class="header-anchor" href="#users-enum" aria-label="Permalink to &quot;Users enum&quot;">​</a></h3><p><a href="https://nmap.org/" target="_blank" rel="noreferrer">nmap</a>&#39;s <code>krb5-enum-users</code> script allows to know wether a username is valid or not (domain-wise) through a legitimate Kerberos service.</p><div class="tip custom-block"><p>A TGT request is made through an <code>AS-REQ</code> message. When an invalid username is requested, the server will respond using the Kerberos error code <code>KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN</code> in the AS-REP message. When working with a valid username, either a TGT will be obtained, or an error like <code>KRB5KDC_ERR_PREAUTH_REQUIRED</code> will be raised (i.e. in this case, indicating that the user is required to perform preauthentication).</p></div><p>The first step in enumerating the usernames is to create a wordlist (by guessing it or by looking for possible associations on social networks).</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>michael.scott</span></span>
<span class="line"><span>jim.halpert</span></span>
<span class="line"><span>oscar.martinez</span></span>
<span class="line"><span>pam.beesly</span></span>
<span class="line"><span>kevin.malone</span></span></code></pre></div><p>The enumeration can then be started.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nmap</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 88</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --script=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;krb5-enum-users&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --script-args=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;krb5-enum-users.realm=&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$DOMAIN</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;,userdb=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$WORDLIST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $IP_DC</span></span></code></pre></div><h3 id="pre-auth-bruteforce-1" tabindex="-1">Pre-auth Bruteforce <a class="header-anchor" href="#pre-auth-bruteforce-1" aria-label="Permalink to &quot;Pre-auth Bruteforce&quot;">​</a></h3><p>Tools like <a href="https://github.com/ropnop/kerbrute" target="_blank" rel="noreferrer">kerbrute</a> (Go) and <a href="https://github.com/ShutdownRepo/smartbrute" target="_blank" rel="noreferrer">smartbrute</a> (Python) can be used to bruteforce credentials through the Kerberos pre-authentication. The smartbrute utility can be used in a <code>brute</code> mode (standard bruteforcing features) or in a <code>smart</code> mode (requires prior knowledge of a low-priv user credentials, but operates LDAP enumeration and avoid locking out accounts, fetches the users list and so on).</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># brute mode, users and passwords lists supplied</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">smartbrute.py</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> brute</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -bU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $USER_LIST </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-bP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $PASSWORD_LIST </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">kerberos</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $DOMAIN</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># smart mode, valid credentials supplied for enumeration</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">smartbrute.py</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> smart</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -bP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $PASSWORD_LIST </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ntlm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $DOMAIN </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-u</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $USER </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $PASSWORD </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">kerberos</span></span></code></pre></div><div class="note custom-block"><p>In its default setup, smartbrute will attack Kerberos pre-authentication with the RC4 etype and the UDP transport protocol. While this configuration is the fastest, there are two downsides:</p><ul><li>bruteforcing with the RC4 etype is not the stealthiest option</li><li>using UDP can lead to some support issues. For instance, a valid authentication on a user part of too many groups could raise a <code>KRB_ERR_RESPONSE_TOO_BIG</code> error. When an authentication attempt is invalid, a common <code>KDC_ERR_PREAUTH_FAILED</code> message should be raised. This allows for bruteforcing, but not authentication.</li></ul></div><div class="warning custom-block"><p class="custom-block-title">Locking out accounts</p><p>As always when bruteforcing passwords in production environments, it is advised to be extra careful. Specific rule and custom tools can be put in place to lock accounts on too many failed attempts. Few offensive tools analyse granular policies. Fewer tools (none to my knowledge) enumerate custom defensive tools configurations.</p></div><h2 id="resources" tabindex="-1">Resources <a class="header-anchor" href="#resources" aria-label="Permalink to &quot;Resources&quot;">​</a></h2><p><a href="https://github.com/ropnop/kerbrute" target="_blank" rel="noreferrer">https://github.com/ropnop/kerbrute</a></p><p><a href="https://nmap.org/nsedoc/scripts/krb5-enum-users.html" target="_blank" rel="noreferrer">https://nmap.org/nsedoc/scripts/krb5-enum-users.html</a></p>`,23)]))}const k=s(r,[["render",n]]);export{u as __pageData,k as default};
